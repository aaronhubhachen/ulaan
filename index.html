<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ulaan</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Oswald:wght@500;700&display=swap');
        
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Inter', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* Custom UI Elements */
        .brand-overlay {
            position: absolute;
            top: 2rem;
            left: 2rem;
            pointer-events: none;
            z-index: 10;
        }
        
        .control-panel {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 99px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10;
        }
        .product-btn {
            background: transparent;
            color: #888;
            border: 1px solid transparent;
            padding: 0.5rem 1.5rem;
            border-radius: 99px;
            cursor: pointer;
            font-family: 'Oswald', sans-serif;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
        }
        .product-btn:hover { color: white; }
        
        .product-btn.active {
            background: #fff;
            color: #000;
            font-weight: bold;
        }
        .info-panel {
            position: absolute;
            right: 2rem;
            top: 50%;
            transform: translateY(-50%);
            width: 300px;
            text-align: right;
            color: white;
            pointer-events: none;
        }
        .loading-overlay {
            position: absolute;
            inset: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loader" class="loading-overlay">
        <div class="text-white font-oswald text-2xl tracking-widest animate-pulse">ULAAN // LOADING</div>
    </div>
    <!-- Brand UI -->
    <div class="brand-overlay">
        <h1 class="text-white font-oswald text-6xl tracking-tighter">ULAAN</h1>
        <p class="text-gray-400 text-sm tracking-widest mt-2">MODERN HERITAGE // GLOBAL STREETWEAR</p>
    </div>
    <!-- Product Info (Dynamic) -->
    <div class="info-panel">
        <h2 id="item-title" class="font-oswald text-4xl mb-2">MONGOLIAN CASHMERE HOODIE</h2>
        <p id="item-desc" class="text-gray-400 text-sm leading-relaxed">
            Sourced directly from the steppe. 100% organic fiber with a modern oversized cut.
        </p>
        <div class="mt-6 flex justify-end gap-4">
            <div class="text-right">
                <div class="text-xs text-gray-500 uppercase">Material</div>
                <div class="font-bold" id="item-mat">Cashmere</div>
            </div>
            <div class="text-right">
                <div class="text-xs text-gray-500 uppercase">Origin</div>
                <div class="font-bold">Ulaanbaatar</div>
            </div>
        </div>
    </div>
    <!-- Controls -->
    <div class="control-panel">
        <button class="product-btn" onclick="switchProduct(0)">Zip-Up</button>
        <button class="product-btn active" onclick="switchProduct(1)">Cashmere Hoodie</button>
        <button class="product-btn" onclick="switchProduct(2)">Beanie</button>
    </div>
    <!-- 3D Canvas -->
    <div id="canvas-container"></div>
    <script>
        // --- CONFIGURATION ---
        // In a real scenario, you would load .gltf models here.
        // Since we are coding this, we will procedurally generate representations.
        const SCENE_CONFIG = {
            bgColor: 0x111111,
            gridColor: 0x333333
        };
        const PRODUCTS = [
            {
                name: "FUR ZIP-UP HOODIE",
                desc: "Heavyweight architectural fleece lined with ethically sourced synthetic wolf fur. Features distressed silver hardware.",
                material: "Faux Fur / Cotton",
                color: 0x333333, // Lightened from 0x222222 for visibility
                type: 'zipup'
            },
            {
                name: "MONGOLIAN CASHMERE HOODIE",
                desc: "Sourced directly from the steppe. 100% organic fiber with a modern oversized cut. Dye-free natural coloration.",
                material: "100% Cashmere",
                color: 0xD2B48C, // Tan/Cashmere color
                type: 'hoodie'
            },
            {
                name: "HERITAGE BEANIE",
                desc: "Ribbed knit construction designed for harsh winters. Features the embroidered Ulaan cyrillic logo.",
                material: "Wool Blend",
                color: 0x8B0000, // Deep Red (Ulaan means Red)
                type: 'beanie'
            }
        ];
        let currentProductIndex = 1;
        let scene, camera, renderer, controls;
        let currentMeshGroup = new THREE.Group();
        let particles;
        // --- INIT ---
        function init() {
            const container = document.getElementById('canvas-container');
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(SCENE_CONFIG.bgColor);
            scene.fog = new THREE.Fog(SCENE_CONFIG.bgColor, 10, 50);
            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 2, 6);
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 3;
            controls.maxDistance = 10;
            controls.maxPolarAngle = Math.PI / 2; // Don't go below floor
            // Lighting
            setupLighting();
            // Environment
            setupEnvironment();
            // Initial Product
            loadProduct(currentProductIndex);
            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            
            // Remove loader
            setTimeout(() => {
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').remove(), 500);
            }, 1000);
            animate();
        }
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); // Increased from 0.4
            scene.add(ambientLight);

            const spotLight = new THREE.SpotLight(0xffffff, 1.5); // Increased intensity
            spotLight.position.set(5, 10, 5);
            spotLight.angle = Math.PI / 4;
            spotLight.penumbra = 0.1;
            spotLight.decay = 2;
            spotLight.distance = 200;
            spotLight.castShadow = true;
            spotLight.shadow.mapSize.width = 1024;
            spotLight.shadow.mapSize.height = 1024;
            scene.add(spotLight);

            // Added Fill Light from Front-Left to illuminate dark models
            const fillLight = new THREE.DirectionalLight(0xffffff, 1.0);
            fillLight.position.set(-2, 4, 6);
            scene.add(fillLight);

            const rimLight = new THREE.SpotLight(0x4455ff, 1.5); // Increased rim light
            rimLight.position.set(-5, 5, -5);
            scene.add(rimLight);
        }
        function setupEnvironment() {
            // Floor
            const floorGeometry = new THREE.PlaneGeometry(50, 50);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x111111,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            // Grid Helper
            const grid = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
            scene.add(grid);
            // Floating Particles (Dust motes)
            const particlesGeometry = new THREE.BufferGeometry();
            const particlesCount = 300;
            const posArray = new Float32Array(particlesCount * 3);
            for(let i = 0; i < particlesCount * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 20;
            }
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.03,
                color: 0xffffff,
                transparent: true,
                opacity: 0.3
            });
            particles = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particles);
        }
        // --- PROCEDURAL GEOMETRY GENERATION ---

        // Helper: Generate procedural noise texture for fabric grain
        function generateNoiseTexture(width, height, opacity = 0.5) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const context = canvas.getContext('2d');
            
            // Fill with base grey
            context.fillStyle = '#808080';
            context.fillRect(0, 0, width, height);
            
            const imageData = context.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                // Random noise intensity
                const noise = (Math.random() - 0.5) * 50 * opacity; 
                // Apply to R, G, B channels
                data[i] = Math.max(0, Math.min(255, 128 + noise));     // R
                data[i+1] = Math.max(0, Math.min(255, 128 + noise));   // G
                data[i+2] = Math.max(0, Math.min(255, 128 + noise));   // B
                data[i+3] = 255; // Alpha
            }
            
            context.putImageData(imageData, 0, 0);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        // Helper: Distort geometry vertices for organic look
        function distortGeometry(geometry, intensity) {
            const pos = geometry.attributes.position;
            for (let i = 0; i < pos.count; i++) {
                pos.setX(i, pos.getX(i) + (Math.random() - 0.5) * intensity);
                pos.setY(i, pos.getY(i) + (Math.random() - 0.5) * intensity);
                pos.setZ(i, pos.getZ(i) + (Math.random() - 0.5) * intensity);
            }
            geometry.computeVertexNormals();
        }
        
        function loadProduct(index) {
            // Clear previous
            scene.remove(currentMeshGroup);
            currentMeshGroup = new THREE.Group();
            const product = PRODUCTS[index];
            
            // Update UI
            document.getElementById('item-title').innerText = product.name;
            document.getElementById('item-desc').innerText = product.desc;
            document.getElementById('item-mat').innerText = product.material;
            // Update Buttons
            document.querySelectorAll('.product-btn').forEach((btn, i) => {
                btn.classList.toggle('active', i === index);
            });

            // Shared Material Properties - UPGRADED to MeshPhysicalMaterial
            const bumpMap = generateNoiseTexture(512, 512, 0.3);
            bumpMap.repeat.set(4, 4);

            let material = new THREE.MeshPhysicalMaterial({
                color: product.color,
                roughness: 0.8, 
                metalness: 0.1,
                bumpMap: bumpMap,
                bumpScale: 0.02,
                side: THREE.DoubleSide,
                clearcoat: 0.0,
                clearcoatRoughness: 1.0,
                sheen: 0.5, // Soft fabric sheen
                sheenColor: 0xffffff,
            });

            if (product.type === 'zipup') {
                // Faux Fur needs more bump and less sheen
                material.roughness = 0.9;
                material.bumpScale = 0.05;
                material.sheen = 0.2;
                createZipUpHoodie(material);
            } else if (product.type === 'hoodie') {
                // Cashmere needs soft sheen and fine grain
                material.roughness = 0.7; // Softer
                material.sheen = 1.0; // High sheen for cashmere soft look
                material.sheenColor = 0xdddddd;
                createCashmereHoodie(material);
            } else if (product.type === 'beanie') {
                // Wool needs high roughness
                material.roughness = 1.0;
                material.sheen = 0.1;
                createBeanie(material);
            }
            
            scene.add(currentMeshGroup);
            
            // Animate entry
            currentMeshGroup.position.y = -1;
            currentMeshGroup.scale.set(0.8, 0.8, 0.8);
        }

        function createZipUpHoodie(baseMaterial) {
            // -- 1. Main Torso --
            const torsoGroup = new THREE.Group();
            
            const torsoGeo = new THREE.CylinderGeometry(0.55, 0.5, 1.5, 64, 16);
            distortGeometry(torsoGeo, 0.03); // Organic distortion
            const torso = new THREE.Mesh(torsoGeo, baseMaterial);
            torso.position.y = 0.75;
            torso.castShadow = true;
            torsoGroup.add(torso);

            // -- 2. Fur Lining Effect --
            const furGeo = new THREE.BufferGeometry();
            const furCount = 4000; // Increased density
            const furPos = [];
            for(let i=0; i<furCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const h = Math.random() * 1.4 - 0.7; 
                const r = 0.54 + Math.random() * 0.05; // Variation in depth
                furPos.push(
                    r * Math.cos(theta), 
                    h + 0.75, 
                    r * Math.sin(theta)
                );
            }
            furGeo.setAttribute('position', new THREE.Float32BufferAttribute(furPos, 3));
            const furMat = new THREE.PointsMaterial({
                color: 0x222222, 
                size: 0.015,
                transparent: true,
                opacity: 0.4,
                sizeAttenuation: true
            });
            const furParticles = new THREE.Points(furGeo, furMat);
            torsoGroup.add(furParticles);

            // -- 3. Sleeves --
            const armGeo = new THREE.CylinderGeometry(0.16, 0.14, 1.3, 32, 8);
            distortGeometry(armGeo, 0.02);
            armGeo.translate(0, -0.5, 0);
            
            const leftArm = new THREE.Mesh(armGeo, baseMaterial);
            leftArm.position.set(0.65, 1.4, 0);
            leftArm.rotation.z = Math.PI / 6;
            leftArm.castShadow = true;

            const rightArm = new THREE.Mesh(armGeo, baseMaterial);
            rightArm.position.set(-0.65, 1.4, 0);
            rightArm.rotation.z = -Math.PI / 6;
            rightArm.castShadow = true;

            torsoGroup.add(leftArm);
            torsoGroup.add(rightArm);

            // -- 4. Hood --
            const hoodGeo = new THREE.SphereGeometry(0.45, 64, 64, 0, Math.PI * 2, 0, Math.PI/2);
            distortGeometry(hoodGeo, 0.02);
            const hood = new THREE.Mesh(hoodGeo, baseMaterial);
            hood.position.set(0, 1.5, -0.1);
            hood.rotation.x = Math.PI + 0.2; 
            hood.scale.z = 0.6;
            hood.castShadow = true;
            torsoGroup.add(hood);

            // -- 5. Zipper --
            const zipGeo = new THREE.BoxGeometry(0.06, 1.5, 0.1);
            const zipMat = new THREE.MeshStandardMaterial({ 
                color: 0xcccccc, 
                metalness: 0.95, 
                roughness: 0.3 
            });
            const zip = new THREE.Mesh(zipGeo, zipMat);
            zip.position.set(0, 0.75, 0.52);
            torsoGroup.add(zip);

            // -- 6. Distressed Details --
            for(let i=0; i<5; i++) {
                const scratchGeo = new THREE.BoxGeometry(0.12, 0.02, 0.02);
                distortGeometry(scratchGeo, 0.01);
                const scratch = new THREE.Mesh(scratchGeo, zipMat);
                scratch.position.set(
                    (Math.random() - 0.5) * 0.5,
                    0.4 + Math.random() * 0.8,
                    0.53
                );
                scratch.rotation.z = (Math.random() - 0.5);
                torsoGroup.add(scratch);
            }

            currentMeshGroup.add(torsoGroup);
        }

        function createCashmereHoodie(baseMaterial) {
            const hoodieGroup = new THREE.Group();

            // -- 1. Oversized Torso --
            const torsoGeo = new THREE.DodecahedronGeometry(0.65, 2); // Higher detail
            distortGeometry(torsoGeo, 0.04); // More distortion for soft fabric
            torsoGeo.applyMatrix4(new THREE.Matrix4().makeScale(1, 1.4, 0.75));
            
            const torso = new THREE.Mesh(torsoGeo, baseMaterial);
            torso.position.y = 0.7;
            torso.castShadow = true;
            hoodieGroup.add(torso);

            // -- 2. Pocket --
            const pocketGeo = new THREE.CylinderGeometry(0.3, 0.35, 0.3, 32, 4, false, 0, Math.PI);
            distortGeometry(pocketGeo, 0.03);
            const pocket = new THREE.Mesh(pocketGeo, baseMaterial);
            pocket.position.set(0, 0.4, 0.38);
            pocket.scale.z = 0.6;
            pocket.castShadow = true;
            hoodieGroup.add(pocket);

            // -- 3. Slouchy Sleeves --
            const sleeveGeo = new THREE.CylinderGeometry(0.18, 0.12, 1.4, 32, 8);
            distortGeometry(sleeveGeo, 0.03);
            sleeveGeo.translate(0, -0.6, 0); 

            const leftSleeve = new THREE.Mesh(sleeveGeo, baseMaterial);
            leftSleeve.position.set(0.55, 1.2, 0);
            leftSleeve.rotation.z = 0.35; 
            leftSleeve.castShadow = true;
            
            const rightSleeve = new THREE.Mesh(sleeveGeo, baseMaterial);
            rightSleeve.position.set(-0.55, 1.2, 0);
            rightSleeve.rotation.z = -0.35;
            rightSleeve.castShadow = true;

            hoodieGroup.add(leftSleeve);
            hoodieGroup.add(rightSleeve);

            // -- 4. Soft Hood --
            const hoodGeo = new THREE.SphereGeometry(0.42, 48, 48);
            distortGeometry(hoodGeo, 0.02);
            const hood = new THREE.Mesh(hoodGeo, baseMaterial);
            hood.position.set(0, 1.3, -0.1);
            hood.scale.set(1.1, 1, 0.7); // Wider hood
            hood.castShadow = true;
            hoodieGroup.add(hood);

            // -- 5. Drawstrings --
            const stringGeo = new THREE.CylinderGeometry(0.015, 0.015, 0.45, 8);
            distortGeometry(stringGeo, 0.005);
            const stringMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            
            const str1 = new THREE.Mesh(stringGeo, stringMat);
            str1.position.set(0.15, 1.1, 0.45);
            str1.rotation.x = 0.3;
            str1.rotation.z = 0.1;
            
            const str2 = new THREE.Mesh(stringGeo, stringMat);
            str2.position.set(-0.15, 1.1, 0.45);
            str2.rotation.x = 0.3;
            str2.rotation.z = -0.1;

            hoodieGroup.add(str1);
            hoodieGroup.add(str2);

            currentMeshGroup.add(hoodieGroup);
        }

        function createBeanie(baseMaterial) {
            const beanieGroup = new THREE.Group();

            // -- 1. Ribbed Dome --
            const layers = 16; // Smoother gradient
            for (let i = 0; i < layers; i++) {
                const t = i / layers;
                const radius = 0.4 * Math.cos(t * Math.PI / 2);
                const y = 0.1 + t * 0.4;
                
                const rowGeo = new THREE.TorusGeometry(radius, 0.03, 8, 48);
                // No distortion on ribs to keep the knit clean look
                const row = new THREE.Mesh(rowGeo, baseMaterial);
                row.rotation.x = Math.PI / 2;
                row.position.y = y;
                row.castShadow = true;
                beanieGroup.add(row);
            }
            
            // Top Pom-pom
            const topGeo = new THREE.SphereGeometry(0.08, 32, 32);
            distortGeometry(topGeo, 0.02);
            const top = new THREE.Mesh(topGeo, baseMaterial);
            top.position.y = 0.52;
            beanieGroup.add(top);

            // -- 2. Thick Cuff --
            const cuffGeo = new THREE.TorusGeometry(0.42, 0.09, 12, 64);
            const cuff = new THREE.Mesh(cuffGeo, baseMaterial);
            cuff.rotation.x = Math.PI / 2;
            cuff.position.y = 0.1;
            cuff.castShadow = true;
            beanieGroup.add(cuff);

            // -- 3. Ulaan Patch --
            const patchGeo = new THREE.BoxGeometry(0.18, 0.12, 0.015);
            distortGeometry(patchGeo, 0.005);
            const patchMat = new THREE.MeshStandardMaterial({ 
                color: 0x111111,
                roughness: 0.9 
            });
            const patch = new THREE.Mesh(patchGeo, patchMat);
            patch.position.set(0, 0.12, 0.50);
            patch.rotation.x = -0.1;
            beanieGroup.add(patch);

            const textGeo = new THREE.PlaneGeometry(0.14, 0.04);
            const textMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const text = new THREE.Mesh(textGeo, textMat);
            text.position.set(0, 0.12, 0.51);
            text.rotation.x = -0.1;
            beanieGroup.add(text);

            currentMeshGroup.add(beanieGroup);
        }
        function switchProduct(index) {
            currentProductIndex = index;
            loadProduct(index);
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function animate() {
            requestAnimationFrame(animate);
            
            controls.update();
            // Rotate particles
            if(particles) {
                particles.rotation.y += 0.001;
            }
            // Floating animation for the product
            if(currentMeshGroup) {
                currentMeshGroup.rotation.y += 0.005;
                
                // Entry lerp
                currentMeshGroup.position.y += (0 - currentMeshGroup.position.y) * 0.05;
                const targetScale = 1;
                currentMeshGroup.scale.x += (targetScale - currentMeshGroup.scale.x) * 0.05;
                currentMeshGroup.scale.y += (targetScale - currentMeshGroup.scale.y) * 0.05;
                currentMeshGroup.scale.z += (targetScale - currentMeshGroup.scale.z) * 0.05;
            }
            renderer.render(scene, camera);
        }
        init();
    </script>
</body>
</html>